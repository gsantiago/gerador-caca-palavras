{"version":3,"sources":["utils.ts","types.ts","components/WordSearch.tsx","components/App.tsx","index.tsx"],"names":["randomNumber","min","max","Math","floor","random","randomChar","String","fromCharCode","range","array","i","push","shuffleArray","temporaryValue","randomIndex","currentIndex","length","UP","direction","modes","DOWN","LEFT","LEFT_UP","LEFT_DOWN","RIGHT","RIGHT_UP","RIGHT_DOWN","styles","td","fontSize","fontFamily","WordSearch","words","size","debug","highlightWords","table","useMemo","points","availableDirections","filter","every","mode","includes","map","y","x","char","isWord","forEach","word","test","createWord","className","row","index","key","letter","col","style","textAlign","textTransform","color","padding","pointIndex","directions","d","directionIndex","xd","yd","xEnd","yEnd","isValid","positions","SIZES","MODES","label","value","ReactDOM","render","useState","state","setState","htmlFor","id","rows","join","onChange","e","target","split","toString","parseInt","type","checked","concat","marginTop","href","document","getElementById"],"mappings":"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","file":"static/js/main.41a86df5.chunk.js","sourcesContent":["export const randomNumber = (min: number, max: number): number =>\n  Math.floor(Math.random() * (max - min + 1) + min)\n\nexport const randomChar = (): string =>\n  String.fromCharCode(randomNumber(65, 90))\n\nexport const range = (min: number, max: number): number[] => {\n  const array = []\n\n  for (let i = 0; i <= max; i += 1) {\n    array.push(i)\n  }\n\n  return array\n}\n\nexport const randomDirection = (): [ number, number ] => {\n  const x = randomNumber(-1, 1)\n  const y = randomNumber(-1, 1)\n\n  if (x === 0 && y === 0) {\n    return randomDirection()\n  }\n\n  return [ x, y ]\n}\n\n// https://stackoverflow.com/a/2450976\nexport const shuffleArray = (array: any[]): any[] => {\n  let currentIndex = array.length\n  let temporaryValue\n  let randomIndex\n\n  while (0 !== currentIndex) {\n    randomIndex = Math.floor(Math.random() * currentIndex)\n    currentIndex -= 1\n\n    temporaryValue = array[currentIndex]\n    array[currentIndex] = array[randomIndex]\n    array[randomIndex] = temporaryValue\n  }\n\n  return array\n}\n","export type Mode = 'horizontal' | 'vertical' | 'diagonal' | 'reversed'\n\nexport type Point = [ number, number ]\n\nexport interface Direction {\n  direction: Point\n  modes: Mode[]\n}\n\nexport const UP: Direction = {\n  direction: [0, -1],\n  modes: ['reversed', 'vertical']\n}\n\nexport const DOWN: Direction = {\n  direction: [0, 1],\n  modes: ['vertical']\n}\n\nexport const LEFT: Direction = {\n  direction: [-1, 0],\n  modes: ['reversed', 'horizontal']\n}\n\nexport const LEFT_UP: Direction = {\n  direction: [-1, -1],\n  modes: ['reversed', 'diagonal']\n}\n\nexport const LEFT_DOWN: Direction = {\n  direction: [-1, 1],\n  modes: ['reversed', 'diagonal']\n}\n\nexport const RIGHT: Direction = {\n  direction: [1, 0],\n  modes: ['horizontal']\n}\n\nexport const RIGHT_UP: Direction = {\n  direction: [1, -1],\n  modes: ['diagonal']\n}\n\nexport const RIGHT_DOWN: Direction = {\n  direction: [1, 1],\n  modes: ['diagonal']\n}\n","import React, { useMemo } from 'react'\nimport { randomChar, range, shuffleArray } from '../utils'\nimport {\n  Mode,\n  Point,\n  Direction,\n  UP,\n  DOWN,\n  LEFT,\n  RIGHT,\n  LEFT_UP,\n  RIGHT_UP,\n  LEFT_DOWN,\n  RIGHT_DOWN\n} from '../types'\n\nfunction WordSearch ({ words, size, modes, debug, highlightWords }: WordSearchProps) {\n  const table: Table = useMemo(() => {\n    const points: Point[] = []\n\n    const availableDirections = [\n      UP,\n      DOWN,\n      LEFT,\n      LEFT_UP,\n      LEFT_DOWN,\n      RIGHT,\n      RIGHT_UP,\n      RIGHT_DOWN\n    ].filter(direction => direction.modes.every(mode => modes.includes(mode)))\n\n    const table: Table = range(0, size - 1).map(y => (\n      range(0, size - 1).map(x => {\n        points.push([ x, y ])\n\n        return {\n          char: randomChar(),\n          isWord: false\n        }\n      })\n    ))\n\n    shuffleArray(points)\n\n    words.forEach(word => {\n      if (/^[A-Za-z]+$/.test(word)) {\n        createWord(\n          word,\n          table,\n          size,\n          shuffleArray(points),\n          availableDirections\n        )\n      }\n    })\n\n    return table\n  }, [words, size, modes])\n\n  return (\n    <div className='word-search'>\n      <table>\n        <tbody>\n          {table.map((row, index) => (\n            <tr key={index}>\n              {row.map((letter, col) => (\n                <td key={col} style={styles.td}>\n                  <div\n                    style={{\n                      textAlign: 'center',\n                      textTransform: 'uppercase',\n                      color: (letter.isWord && highlightWords) ? 'red' : 'black',\n                      padding: debug ? 15 : 5\n                    }}\n                  >\n                    {letter.char}\n                    {debug && (\n                      <div style={{ fontSize: 8 }}>\n                        {index},{col}\n                      </div>\n                    )}\n                  </div>\n                </td>\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  )\n}\n\ninterface WordSearchProps {\n  words: string[]\n  size: number\n  modes: Mode[]\n  debug?: boolean\n  highlightWords: boolean\n}\n\ninterface Letter {\n  char: string\n  isWord: boolean\n}\n\ntype Table = Letter[][]\n\nconst styles = {\n  td: {\n    fontSize: 18,\n    fontFamily: 'sans-serif'\n  }\n}\n\nexport default WordSearch\n\nconst createWord = (word: string, table: Table, size: number, points: Point[], availableDirections: Direction[]): void => {\n  for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n    const [ x, y ] = points[pointIndex]\n\n    const directions = shuffleArray(availableDirections.map(d => d.direction))\n\n    for (let directionIndex = 0; directionIndex < directions.length; directionIndex += 1) {\n      const [ xd, yd ] = directions[directionIndex]\n\n      const xEnd = x + (word.length - 1) * xd\n      const yEnd = y + (word.length - 1) * yd\n\n      if (yEnd > size - 1 || yEnd < 0 || xEnd > size - 1 || xEnd < 0) {\n        continue\n      }\n\n      let isValid = true\n      let positions: Point[] = []\n\n      for (\n        let col = x, row = y, i = 0;\n        i < word.length;\n        col += xd, row += yd, i += 1\n      ) {\n        if (table[row][col].isWord && table[row][col].char !== word[i]) {\n          isValid = false\n          break\n        }\n\n        positions.push([ col, row ])\n      }\n\n      if (!isValid) {\n        continue\n      }\n\n      positions.forEach(([ x, y ], index) => {\n        table[y][x] = {\n          char: word[index],\n          isWord: true\n        }\n      })\n\n      return\n    }\n  }\n}\n","import React, { useState } from 'react'\nimport WordSearch from './WordSearch'\nimport {Mode} from '../types'\n\nconst SIZES = [10, 15, 20, 25, 30]\n\nconst MODES: { label: string, value: Mode }[] = [\n  {\n    label: 'Horizontal',\n    value: 'horizontal'\n  },\n  {\n    label: 'Vertical',\n    value: 'vertical'\n  },\n  {\n    label: 'Diagonal',\n    value: 'diagonal'\n  },\n  {\n    label: 'Trás pra frente',\n    value: 'reversed'\n  }\n]\n\nexport default function App () {\n  const [ state, setState ] = useState<{\n    words: string[]\n    size: number\n    modes: Mode[]\n    highlightWords: boolean\n  }>({\n    words: ['carro', 'bicicleta', 'brasil', 'curitiba', 'futebol', 'lambreta'],\n    size: 20,\n    modes: [\n      'horizontal',\n      'vertical',\n      'diagonal',\n      'reversed'\n    ],\n    highlightWords: true\n  })\n\n  return (\n    <div className='container'>\n      <h1>Gerador de caça-palavras</h1>\n      <div className='field'>\n        <label className='label' htmlFor='words'>Lista de palavras que você deseja incluir:</label>\n        <textarea\n          id='words'\n          rows={10}\n          value={state.words.join('\\n')}\n          onChange={e => setState({ ...state, words: e.target.value.split('\\n') })}\n        />\n        <label htmlFor='words' className='help'>\n          Insira uma palavra por linha. As palavras não podem ter acentos, caracteres especiais ou espaço. Palavras inválidas serão desconsideradas.\n        </label>\n      </div>\n      <div className='field'>\n        <label className='label' htmlFor='size'>Tamanho (linhas x colunas):</label>\n        <select\n          id='size'\n          value={state.size.toString()}\n          onChange={e => setState({ ...state, size: parseInt(e.target.value, 10) })}\n        >\n          {SIZES.map(size => (\n            <option key={size} value={size.toString()}>{size}x{size}</option>\n          ))}\n        </select>\n      </div>\n      <div className='field'>\n        <label className='label' htmlFor='modes'>Modos:</label>\n        {MODES.map(mode => (\n          <div key={mode.value}>\n            <label className='checkbox'>\n              <input\n                type='checkbox'\n                onChange={e => setState({\n                  ...state,\n                  modes: e.target.checked\n                    ? state.modes.concat(mode.value)\n                    : state.modes.filter(value => value !== mode.value)\n                })}\n                checked={state.modes.includes(mode.value)}\n              />\n              <span>{mode.label}</span>\n            </label>\n          </div>\n        ))}\n      </div>\n      <div className='field'>\n        <label htmlFor='options' className='label'>Opções de visualização:</label>\n        <div>\n          <label className='checkbox'>\n            <input\n              type='checkbox'\n              checked={state.highlightWords}\n              onChange={() => setState({ ...state, highlightWords: !state.highlightWords })}\n            />\n            <span>Destacar as palavras</span>\n          </label>\n        </div>\n      </div>\n      <WordSearch\n        words={state.words}\n        size={state.size}\n        modes={state.modes}\n        highlightWords={state.highlightWords}\n        debug={false}\n      />\n      <div style={{ marginTop: 30 }}>\n        <span className='label'>Dicas</span>\n        <ul>\n          <li>\n            Você pode copiar o caça palavras e colar num documento Word ou editor semelhante.\n          </li>\n          <li>\n            Algumas palavras podem não aparecer no caça-palavras por serem inválidas (possuem caracteres especiais, espaço, acentuação, etc) ou não foi possível encaixá-la no caça-palavras por falta de espaço.\n          </li>\n          <li>\n            <a href='https://github.com/gsantiago/gerador-de-caca-palavras/issues/new'>Clique aqui</a> para enviar uma sugestão ou reportar um bug.\n          </li>\n          <li>\n            <a href='https://github.com/gsantiago/gerador-de-caca-palavras'>Clique aqui</a> para conferir o código-fonte do projeto.\n          </li>\n        </ul>\n      </div>\n      <footer>\n        Desenvolvido por <a href='https://github.com/gsantiago'>gsantiago</a>\n      </footer>\n    </div>\n  )\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './components/App'\nimport './styles.css'\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}